// function to enumerate a genus using canonical forms
Z := Integers();
Q := Rationals();
load "aut-char.mag";
Attach("canonical_form.m");
Attach("my_neighbors.m");

// A very quick lattice hash.  This is better with a faster
// OrthogonalDecomposition (cf. my email)
function root_sub(lat)
  rl := {*Strings()|*};
  tor := [];
  sl := sub<lat|[x[1]: x in ShortVectors(lat,2,2)]>;
  Zn := RSpace(Z,Dimension(lat));
  slzn := sub<Zn|[Eltseq(i): i in ShortestVectors(lat)]>;
  tor := Moduli(Saturation(slzn)/slzn);
  od := OrthogonalDecomposition(sl);
  for i in od do
    sdi := IntegerToString(Dimension(i));
    for l in ["A","D","E"] do
      if IsIsomorphic(i,LatticeWithGram(CartanMatrix(l*sdi))) then
        Include(~rl,l*sdi);
        continue i;
      end if;
    end for;
    error "impossible root lattice", Eltseq(GramMatrix(lat));
  end for;
  return rl,tor,#ShortVectors(lat,4,4);
end function;

// Function to enumerate the p-neighbourhood of a lattice using the
// canonical form of DS-H-V-vW, as implemented in canonical_form.m.
// Arguments:

// pd: the lattice
// bd: stop after considering this number of lattices
// p: the prime for p-neighbours
// done: initial list of lattices in the genus
// silent: stops the code from babbling (overridden by "show")
// aut_gp_fn, nb_fn, cf_fn: custom functions for finding Aut(L),
// the p-neighbours of a lattice, and a canonical form
// thorough included for backward compatibility

// bd := Infinity(); p := 2; done := {@@}; silent := false; aut_gp_fn := AutomorphismGroup; nb_fn := Neighbours; cf_fn := func<x|CanonicalForm(GramMatrix(x))>; hash := func<x|<a,b,c> where a,b,c is root_sub(x)>;
stoi := func<l,i|sub<l|[x[1]: x in ShortVectors(l,i)]>>;
function list_genus(pd: bd := Infinity(), p := 2, done := {@@}, silent := false, aut_gp_fn := AutomorphismGroup, nb_fn := Neighbours, cf_fn := func<x|CanonicalForm(GramMatrix(x))>, hash := func<x|<a,b,c,d> where a,b,c is root_sub(x) where d is [Rank(stoi(x,i)): i in [1..6]]>, thorough := true)
  _ := aut_gp_fn(pd);
  g := Genus(pd);
  mass := Mass(pd);
  todo := {@pd@}; rss := [];
  cp := Cputime(); ct := 0;
  can_forms := {@@};
  mass_left := mass;
  hashes := [hash(pd)];
  found_hashes := {@@};
  
  while #todo gt 0 and #done lt bd and mass_left gt 0 do
    ct +:= 1;
    if not silent then
      if ct mod 100 eq 0 then
        printf "%o done, %o found, %o left, time taken %o\n", ct, #done, #todo, Cputime(cp);
      else printf ".";
      end if;
    end if;
    good_inds := [x: x in [1..#todo]|hashes[x] notin found_hashes];
    ind := (#good_inds gt 0 select Random(good_inds) else Random(1,#todo));
    l := todo[ind];
    cf := cf_fn(l);
    todo := {@todo[i]: i in Remove([1..#todo],ind)@};
    the_hash := hashes[ind];
    Remove(~hashes,ind);
    if cf notin can_forms then
      Include(~done,l);
      Include(~can_forms,cf);
      Include(~found_hashes,the_hash);
      ag := aut_gp_fn(l);
      mass_left -:= 1/#ag;
      if not silent then <<a,b,c> where a,b,c is root_sub(l),RealField(5)!(mass_left/mass), #l`AutomorphismGroup>; end if;
      if mass_left eq 0 then
        g`Representatives := done;
      else
        nlat := {@LatticeWithGram(GramMatrix(n)): n in nb_fn(l,p)|n notin done@};
        todo join:= nlat;
        hashes cat:= [hash(i): i in nlat];
      end if;
    end if;
  end while;
  if mass_left gt 0 then "warning: finished exploring the graph but still missing", mass_left, "of mass; consider rerunning with larger p"; end if;
  return done,can_forms,g;
end function;

/*
load "neighbours_canonical.mag";
l := LatticeWithGram(CartanMatrix("d8d8"));
SetVerbose("Lattice",2);
SetVerbose("CanonicalForm",2);
nb := list_genus(l:nb_fn := newNeighbours,aut_gp_fn := aut_faster);
*/

// Unfortunately the CanonicalForm intrinsic that comes with Magma
// is not genuinely canonical.
// Here are two 11 x 11 Gram matrices that define isomorphic lattices:
/*bad_mats := [[ 2, 0, 1, -1, -1, -1, -1, -2, -1, -1, -1, 0, 4, -1, 1, 0, 0, 0, 1, 0, 0, -1, 1, -1, 2, -1, 0, 0, 0, -2, 0, 0, 0, -1, 1, -1, 2, 1, 1, 1, 2, 1, 1, -1, -1, 0, 0, 1, 3, 2, 2, 1, 1, 1, 1, -1, 0, 0, 1, 2, 3, 1, 2, 1, 2, 2, -1, 0, 0, 1, 2, 1, 3, 1, 2, 1, 0, -2, 1, -2, 2, 1, 2, 1, 5, 2, 2, 2, -1, 0, 0, 1, 1, 1, 2, 2, 3, 2, 1, -1, 0, 0, 1, 1, 2, 1, 2, 2, 3, 2, -1, -1, 0, -1, 1, 2, 0, 2, 1, 2, 6 ],
             [ 2, 1, -1, -1, -1, 0, 0, 1, -1, -2, -2, 1, 2, -1, 0, 0, 0, 0, 1, 0, 0, 0, -1, -1, 2, 1, 1, 0, 0, 0, 1, 2, 2, -1, 0, 1, 3, 2, 1, -1, 0, 2, 2, 3, -1, 0,1, 2, 3, 0, -1, 0, 2, 3, 3, 0, 0, 0, 1, 0, 2, -1, 0, 0, -3, -2, 0, 0, 0, -1,-1, -1, 2, 0, -1, 2, 2, 1, 1, 0, 0, 0, 0, 0, 4, 0, 0, 0, -1, 0, 1, 2, 2, 0, -1, 0, 3, 3, 3, -2, 0, 2, 2, 3, -3, 2, 0, 3, 12, 11, -2, 0, 2, 3, 3, -2, 2, 0, 3, 11, 12 ]];
bad_lats := [LatticeWithGram(Matrix(11,11,i)): i in bad_mats];
assert IsIsomorphic(bad_lats[1],bad_lats[2]);
assert CanonicalForm(bad_lats[1]) ne CanonicalForm(bad_lats[2]);
*/
// Update: it now works, using the new intrinsic in canonical_form.m.

// a lattice that causes problems for the canonical form:
// badl := LatticeWithGram(Matrix([[2,1,1,-1,-1,1,-1,-1,0,1,1,2,1,1,0,2],[1,2,1,-1,-1,1,-1,0,0,0,0,2,1,1,0,2],[1,1,2,-1,-1,1,-1,-1,-1,1,1,2,1,1,0,2],[-1,-1,-1,2,1,-1,1,1,1,0,0,-2,-1,-1,0,-2],[-1,-1,-1,1,2,-1,1,0,1,-1,-1,-2,-1,-1,0,-2],[1,1,1,-1,-1,2,-1,0,-1,0,0,2,1,1,0,2],[-1,-1,-1,1,1,-1,2,0,1,0,0,-2,-1,-1,0,-2],[-1,0,-1,1,0,0,0,4,1,-1,-1,-1,0,-1,0,0],[0,0,-1,1,1,-1,1,1,4,0,0,-1,0,-1,0,-2],[1,0,1,0,-1,0,0,-1,0,4,3,1,0,0,1,1],[1,0,1,0,-1,0,0,-1,0,3,4,1,0,0,1,1],[2,2,2,-2,-2,2,-2,-1,-1,1,1,4,2,2,0,3],[1,1,1,-1,-1,1,-1,0,0,0,0,2,2,1,0,1],[1,1,1,-1,-1,1,-1,-1,-1,0,0,2,1,2,0,1],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,2,0],[2,2,2,-2,-2,2,-2,0,-2,1,1,3,1,1,0,6]]));
